# alias less='less -m -N -g -i -J --line-numbers --underline-special'
# export LESSOPEN="lessopen %s"
# export LESCLOSE="lessclose %s %s"
alias more='less'

# unregister broken GHC packages. Run this a few times to resolve dependency rot in installed packages.
# ghc-pkg-clean -f cabal/dev/packages*.conf also works.
function ghc-pkg-clean() {
  for p in `ghc-pkg check $* 2>&1  | grep problems | awk '{print $6}' | sed -e 's/:$//'`
  do
    echo unregistering $p; ghc-pkg $* unregister $p
  done
}

# remove all installed GHC/cabal packages, leaving ~/.cabal binaries and docs in place.
# When all else fails, use this to get out of dependency hell and start over.
function ghc-pkg-reset() {
  if [[ $(readlink -f /proc/$$/exe) =~ zsh ]]; then
    read 'ans?Erasing all your user ghc and cabal packages - are you sure (y/N)? '
  else # assume bash/bash compatible otherwise
    read -p 'Erasing all your user ghc and cabal packages - are you sure (y/N)? ' ans
  fi

  [[ x$ans =~ "xy" ]] && ( \
    echo 'erasing directories under ~/.ghc'; command rm -rf `find ~/.ghc/* -maxdepth 1 -type d`; \
    echo 'erasing ~/.cabal/lib'; command rm -rf ~/.cabal/lib; \
  )
}

alias cabalupgrades="cabal list --installed  | egrep -iv '(synopsis|homepage|license)'"

## custom functions
# calls cd, and lists contents of directory
function cdl {
    cd "$@" && ls -lAh
}

function runHaskTagsVim {
  hasktags --ignore-close-implementation --ctags .; sort tags
}

function prepend {
    if [ -e $2 ]; then
        sed -i -e '1i$2\' $2
    fi
}

man() {
    env LESS_TERMCAP_mb=$'\E[01;31m' \
    LESS_TERMCAP_md=$'\E[01;38;5;74m' \
    LESS_TERMCAP_me=$'\E[0m' \
    LESS_TERMCAP_se=$'\E[0m' \
    LESS_TERMCAP_so=$'\E[38;5;246m' \
    LESS_TERMCAP_ue=$'\E[0m' \
    LESS_TERMCAP_us=$'\E[04;38;5;146m' \
    man "$@"
}

# taken from itchyny on Github, with some small alterations
# suffix alias according to file extension
alias -s txt=cat
alias -s {csv,js,css,less,md}=vi
alias -s tex=autolatex
alias -s html=chromium
alias -s pdf=zathura
alias -s {png,jpg,bmp,PNG,JPG,BMP}=feh
alias -s {mp3,mp4,wav,mkv,m4v,m4a,wmv,avi,mpeg,mpg,vob,mov,rm}=mplayer
alias -s py=python
alias -s hs=runhaskell
alias -s sh=sh

function extract() {
  case $1 in
    *.tar.gz|*.tgz) tar xzvf "$1";;
    *.tar.xz) tar Jxvf "$1";;
    *.zip) unzip "$1";;
    *.tar.bz2|*.tbz) tar xjvf "$1";;
    *.tar.Z) tar zxvf "$1";;
    *.gz) gzip -d "$1";;
    *.bz2) bzip2 -dc "$1";;
    *.Z) uncompress "$1";;
    *.tar) tar xvf "$1";;
  esac
}

alias -s {gz,tgz,zip,lzh,bz2,tbz,Z,tar,arj,xz}=extract

# list all installed binaries
alias allBinaries="compgen -c | sed '/^_/d' | sort"

###-begin-npm-completion-###
#
# npm command completion script
#
# Installation: npm completion >> ~/.bashrc  (or ~/.zshrc)
# Or, maybe: npm completion > /usr/local/etc/bash_completion.d/npm
#

if type complete &>/dev/null; then
  _npm_completion () {
    local words cword
    if type _get_comp_words_by_ref &>/dev/null; then
      _get_comp_words_by_ref -n = -n @ -w words -i cword
    else
      cword="$COMP_CWORD"
      words=("${COMP_WORDS[@]}")
    fi

    local si="$IFS"
    IFS=$'\n' COMPREPLY=($(COMP_CWORD="$cword" \
                           COMP_LINE="$COMP_LINE" \
                           COMP_POINT="$COMP_POINT" \
                           npm completion -- "${words[@]}" \
                           2>/dev/null)) || return $?
    IFS="$si"
  }
  complete -o default -F _npm_completion npm
elif type compdef &>/dev/null; then
  _npm_completion() {
    local si=$IFS
    compadd -- $(COMP_CWORD=$((CURRENT-1)) \
                 COMP_LINE=$BUFFER \
                 COMP_POINT=0 \
                 npm completion -- "${words[@]}" \
                 2>/dev/null)
    IFS=$si
  }
  compdef _npm_completion npm
elif type compctl &>/dev/null; then
  _npm_completion () {
    local cword line point words si
    read -Ac words
    read -cn cword
    let cword-=1
    read -l line
    read -ln point
    si="$IFS"
    IFS=$'\n' reply=($(COMP_CWORD="$cword" \
                       COMP_LINE="$line" \
                       COMP_POINT="$point" \
                       npm completion -- "${words[@]}" \
                       2>/dev/null)) || return $?
    IFS="$si"
  }
  compctl -K _npm_completion npm
fi
###-end-npm-completion-###

function _ott_commands() {
    local ret=1 state
    _arguments ':subcommand:->subcommand' && ret=0

    case $state in
      subcommand)
        subcommands=(
        "-i <filename>:Input file (can be used multiple times)"
        "-o <filename>:Output file (can be used multiple times)"
        "-writesys <filename>:Output system definition"
        "-readsys <filename>:Input system definition"
        "-tex_filter <src><dst>:Files to TeX filter"
        "-coq_filter <src><dst>:Files to Coq filter"
        "-hol_filter <src><dst>:Files to HOL filter"
        "-lem_filter <src><dst>:Files to HOL filter"
        "-isa_filter <src><dst>:Files to Isabelle filter"
        "-ocaml_filter <src><dst>:Files to OCaml filter"
        "-merge:merge grammar and definition rules, default <false>"
        "-parse:Test parse symterm,eg \":nontermroot: term\""
        "-fast_parse <false>:do not parse :rulename: pseudoterminals"
        "-signal_parse_errors <false>:return >0 if there are bad defns"
        "-picky_multiple_parses <false>:Picky about multiple parses"
        "-generate_aux_rules <true>:Generate auxiliary rules from {{ aux ... }} homs"
        "-output_source_locations <0>:Include source location info in output (0=none, 1=drules, 2=grammar+drules)"
        "-colour <true>:Use (vt220) colour for ASCII pretty print"
        "-show_sort <false>:Show ASCII pretty print of syntax"
        "-show_defns <false>:Show ASCII pretty print defns"
        "-tex_show_meta <true>:Include meta prods and rules in TeX output"
        "-tex_show_categories <false>:Signal production flags in TeX output"
        "-tex_colour <true>:Colour parse errors in TeX output"
        "-tex_wrap <true>:Wrap TeX output in document pre/postamble"
        "-tex_name_prefix <string>:Prefix for tex commands (default "ott")"
        "-isabelle_primrec <true>:Use \"primrec\" instead of \"fun\" for functions"
        "-isabelle_inductive <true>:Use \"inductive\" instead of \"inductive_set for relations\""
        "-isa_syntax <false>:Use fancy syntax in Isabelle output"
        "-isa_generate_lemmas <false>:Lemmas for collapsed functions in Isabelle"
        "-coq_avoid <1>:coq type-name avoidance (0=nothing, 1=avoid, 2=secondaryify)"
        "-coq_expand_list_types <true>:Expand list types in Coq output"
        "-coq_lngen <false>:lngen compatibility"
        "-coq_names_in_rules <true>:Copy user names in rule definitions"
        "-coq_use_filter_fn <false>:Use list_filter instead of list_minus2 in substitutions"
        "-ocaml_include_terminals <false>:Include terminals in OCaml output (experimental!)"
        "-pp_grammar:(debug) print term grammar"
        "-dot <filename>:(debug) dot graph of syntax dependencies"
        "-alltt <filename>:(debug) alltt output of single source file"
        "-sort <true>:(debug) do topological sort"
        "-process_defns <true>:(debug) process inductive reln definitions"
        "-showraw <false>:(debug) show raw grammar"
        "-ugly <false>:(debug) use ugly ASCII output"
        "-no_rbcatn <true>:(debug) remove relevant bind clauses"
        "-lem_debug:(debug) print lem debug locations"
        "-help:Display this list of options"
        "--help:Display this list of options"
        )
        _describe -t subcommands 'ott subcommands' subcommands && ret=0
    esac

    return ret
}

compdef _ott_commands ott


function _idris_commands() {
    local ret=1 state
    _arguments ':subcommand:->subcommand' && ret=0

    case $state in
      subcommand)
        subcommands=(
            "--nobanner:Suppress the banner"
            "-q,--quiet:Quiet verbosity"
            "--ide-mode:Run the Idris REPL with machine-readable syntax"
            "--ide-mode-socket:Choose a socket for IDE mode to listen on"
            "--log:Debugging log level"
            "--logging-categories:Colon separated logging categories. Use --listlogcats to see list."
            "--nobasepkgs:Do not use the given base package"
            "--noprelude:Do not use the given prelude"
            "--nobuiltins:Do not use the builtin functions"
            "--check:Typecheck only, don't start the REPL"
            "-o,--output:FILE         Specify output file"
            "--interface:Generate interface files from ExportLists"
            "--typeintype:Turn off Universe checking"
            "--total:Require functions to be total by default"
            "--warnpartial:Warn about undeclared partial functions"
            "--warnreach:Warn about reachable but inaccessible arguments"
            "--warnipkg:Warn about possible incorrect package specifications"
            "--info:Display information about installation."
            "--listlogcats:Display logging categories"
            "--link:Display link flags"
            "--listlibs:Display installed libraries"
            "--libdir:Display library directory"
            "--docdir:Display idrisdoc install directory"
            "--include:Display the includes flags"
            "--V2:Loudest verbosity"
            "--V1:Louder verbosity"
            "-V,--V0,--verbose:Loud verbosity"
            "--ibcsubdir:Write IBC files into sub directory"
            "-i,--idrispath:Add directory to the list of import paths"
            "--sourcepath:Add directory to the list of source search paths"
            "-p,--package:Add package as a dependency"
            "--port:REPL TCP port - pass "none" to not bind any port"
            "--build:Build package"
            "--install:Install package"
            "--repl:Launch REPL, only for executables"
            "--clean:Clean package"
            "--mkdoc:Generate IdrisDoc for package"
            "--installdoc:Install IdrisDoc for package"
            "--checkpkg:Check package only"
            "--testpkg:Run tests for package"
            "--indent-with:Indentation to use with :makewith (default 2)"
            "--indent-clause:Indentation to use with :addclause (default 2)"
            "-S,--codegenonly:Do no further compilation of code generator output"
            "-c,--compileonly:Compile to object files rather than an executable"
            "--codegen:Select code generator: C, Javascript, Node and bytecode are bundled with Idris"
            "--portable-codegen:Pass the name of the code generator. This option is for codegens that take JSON formatted IR."
            "--cg-opt:Arguments to pass to code generator"
            "-e,--eval:EXPR           Evaluate an expression without loading the REPL"
            "--execute:Execute as idris"
            "--exec:EXPR              Execute as idris"
            "-X,--extension:EXT       Turn on language extension (TypeProviders or ErrorReflection)"
            "--no-partial-eval:Switch off partial evaluation, mainly for debugging purposes"
            "--target:TRIPLE          If supported the codegen will target the named triple."
            "--cpu:CPU                If supported the codegen will target the named CPU e.g. corei7 or cortex-m3"
            "--color,--colour:Force coloured output"
            "--nocolor,--nocolour:Disable coloured output"
            "--consolewidth:Select console width: auto, infinite, nat"
            "--highlight:Emit source code highlighting"
            "--no-elim-deprecation-warnings:Disable deprecation warnings for %elim"
            "--no-tactic-deprecation-warnings:Disable deprecation warnings for the old tactic sublanguage"
            "-v,--version:Print version information"
            "-h,--help:Show this help text"
        )
        _describe -t subcommands 'idris subcommands' subcommands && ret=0
    esac

    return ret
}

compdef _idris_commands idris
