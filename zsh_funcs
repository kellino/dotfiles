# alias less='less -m -N -g -i -J --line-numbers --underline-special'
# export LESSOPEN="lessopen %s"
# export LESCLOSE="lessclose %s %s"
alias more='less'

# unregister broken GHC packages. Run this a few times to resolve dependency rot in installed packages.
# ghc-pkg-clean -f cabal/dev/packages*.conf also works.
function ghc-pkg-clean() {
  for p in `ghc-pkg check $* 2>&1  | grep problems | awk '{print $6}' | sed -e 's/:$//'`
  do
    echo unregistering $p; ghc-pkg $* unregister $p
  done
}

# remove all installed GHC/cabal packages, leaving ~/.cabal binaries and docs in place.
# When all else fails, use this to get out of dependency hell and start over.
function ghc-pkg-reset() {
  if [[ $(readlink -f /proc/$$/exe) =~ zsh ]]; then
    read 'ans?Erasing all your user ghc and cabal packages - are you sure (y/N)? '
  else # assume bash/bash compatible otherwise
    read -p 'Erasing all your user ghc and cabal packages - are you sure (y/N)? ' ans
  fi

  [[ x$ans =~ "xy" ]] && ( \
    echo 'erasing directories under ~/.ghc'; command rm -rf `find ~/.ghc/* -maxdepth 1 -type d`; \
    echo 'erasing ~/.cabal/lib'; command rm -rf ~/.cabal/lib; \
  )
}

alias cabalupgrades="cabal list --installed  | egrep -iv '(synopsis|homepage|license)'"

## custom functions
# calls cd, and lists contents of directory
function cdl {
    cd "$@" && ls -lAh
}

function runHaskTagsVim {
  hasktags --ignore-close-implementation --ctags .; sort tags
}

function prepend {
    if [ -e $2 ]; then
        sed -i -e '1i$2\' $2
    fi
}

man() {
    env LESS_TERMCAP_mb=$'\E[01;31m' \
    LESS_TERMCAP_md=$'\E[01;38;5;74m' \
    LESS_TERMCAP_me=$'\E[0m' \
    LESS_TERMCAP_se=$'\E[0m' \
    LESS_TERMCAP_so=$'\E[38;5;246m' \
    LESS_TERMCAP_ue=$'\E[0m' \
    LESS_TERMCAP_us=$'\E[04;38;5;146m' \
    man "$@"
}

# taken from itchyny on Github, with some small alterations
# suffix alias according to file extension
alias -s txt=cat
alias -s {csv,js,css,less,md}=vi
alias -s tex=autolatex
alias -s html=chromium
alias -s pdf=zathura
alias -s {png,jpg,bmp,PNG,JPG,BMP}=feh
alias -s {mp3,mp4,wav,mkv,m4v,m4a,wmv,avi,mpeg,mpg,vob,mov,rm}=mplayer
alias -s py=python
alias -s hs=runhaskell
alias -s sh=sh

function extract() {
  case $1 in
    *.tar.gz|*.tgz) tar xzvf "$1";;
    *.tar.xz) tar Jxvf "$1";;
    *.zip) unzip "$1";;
    *.tar.bz2|*.tbz) tar xjvf "$1";;
    *.tar.Z) tar zxvf "$1";;
    *.gz) gzip -d "$1";;
    *.bz2) bzip2 -dc "$1";;
    *.Z) uncompress "$1";;
    *.tar) tar xvf "$1";;
  esac
}

alias -s {gz,tgz,zip,lzh,bz2,tbz,Z,tar,arj,xz}=extract

# list all installed binaries
alias allBinaries="compgen -c | sed '/^_/d' | sort"

###-begin-npm-completion-###
#
# npm command completion script
#
# Installation: npm completion >> ~/.bashrc  (or ~/.zshrc)
# Or, maybe: npm completion > /usr/local/etc/bash_completion.d/npm
#

if type complete &>/dev/null; then
  _npm_completion () {
    local words cword
    if type _get_comp_words_by_ref &>/dev/null; then
      _get_comp_words_by_ref -n = -n @ -w words -i cword
    else
      cword="$COMP_CWORD"
      words=("${COMP_WORDS[@]}")
    fi

    local si="$IFS"
    IFS=$'\n' COMPREPLY=($(COMP_CWORD="$cword" \
                           COMP_LINE="$COMP_LINE" \
                           COMP_POINT="$COMP_POINT" \
                           npm completion -- "${words[@]}" \
                           2>/dev/null)) || return $?
    IFS="$si"
  }
  complete -o default -F _npm_completion npm
elif type compdef &>/dev/null; then
  _npm_completion() {
    local si=$IFS
    compadd -- $(COMP_CWORD=$((CURRENT-1)) \
                 COMP_LINE=$BUFFER \
                 COMP_POINT=0 \
                 npm completion -- "${words[@]}" \
                 2>/dev/null)
    IFS=$si
  }
  compdef _npm_completion npm
elif type compctl &>/dev/null; then
  _npm_completion () {
    local cword line point words si
    read -Ac words
    read -cn cword
    let cword-=1
    read -l line
    read -ln point
    si="$IFS"
    IFS=$'\n' reply=($(COMP_CWORD="$cword" \
                       COMP_LINE="$line" \
                       COMP_POINT="$point" \
                       npm completion -- "${words[@]}" \
                       2>/dev/null)) || return $?
    IFS="$si"
  }
  compctl -K _npm_completion npm
fi
###-end-npm-completion-###

function _ott_commands() {
    local ret=1 state
    _arguments ':subcommand:->subcommand' && ret=0

    case $state in
      subcommand)
        subcommands=(
        "-i <filename>:Input file (can be used multiple times)"
        "-o <filename>:Output file (can be used multiple times)"
        "-writesys <filename>:Output system definition"
        "-readsys <filename>:Input system definition"
        "-tex_filter <src><dst>:Files to TeX filter"
        "-coq_filter <src><dst>:Files to Coq filter"
        "-hol_filter <src><dst>:Files to HOL filter"
        "-lem_filter <src><dst>:Files to HOL filter"
        "-isa_filter <src><dst>:Files to Isabelle filter"
        "-ocaml_filter <src><dst>:Files to OCaml filter"
        "-merge <false>:merge grammar and definition rules"
        "-parse <string>:Test parse symterm,eg ":nontermroot: term""
        "-fast_parse <false>:do not parse :rulename: pseudoterminals"
        "-signal_parse_errors <false>:return >0 if there are bad defns"
        "-picky_multiple_parses <false>:Picky about multiple parses"
        "-generate_aux_rules <true>:Generate auxiliary rules from {{ aux ... }} homs"
        "-output_source_locations <0>:Include source location info in output (0=none, 1=drules, 2=grammar+drules)"
        "-colour <true>:Use (vt220) colour for ASCII pretty print"
        "-show_sort <false>:Show ASCII pretty print of syntax"
        "-show_defns <false>:Show ASCII pretty print defns"
        "-tex_show_meta <true>:Include meta prods and rules in TeX output"
        "-tex_show_categories <false>:Signal production flags in TeX output"
        "-tex_colour <true>:Colour parse errors in TeX output"
        "-tex_wrap <true>:Wrap TeX output in document pre/postamble"
        "-tex_name_prefix <string>:Prefix for tex commands (default "ott")"
        "-isabelle_primrec <true>:Use \"primrec\" instead of \"fun\" for functions"
        "-isabelle_inductive <true>:Use \"inductive\" instead of \"inductive_set for relations\""
        "-isa_syntax <false>:Use fancy syntax in Isabelle output"
        "-isa_generate_lemmas <false>:Lemmas for collapsed functions in Isabelle"
        "-coq_avoid <1>:coq type-name avoidance (0=nothing, 1=avoid, 2=secondaryify)"
        "-coq_expand_list_types <true>:Expand list types in Coq output"
        "-coq_lngen <false>:lngen compatibility"
        "-coq_names_in_rules <true>:Copy user names in rule definitions"
        "-coq_use_filter_fn <false>:Use list_filter instead of list_minus2 in substitutions"
        "-ocaml_include_terminals <false>:Include terminals in OCaml output (experimental!)"
        "-pp_grammar:(debug) print term grammar"
        "-dot <filename>:(debug) dot graph of syntax dependencies"
        "-alltt <filename>:(debug) alltt output of single source file"
        "-sort <true>:(debug) do topological sort"
        "-process_defns <true>:(debug) process inductive reln definitions"
        "-showraw <false>:(debug) show raw grammar"
        "-ugly <false>:(debug) use ugly ASCII output"
        "-no_rbcatn <true>:(debug) remove relevant bind clauses"
        "-lem_debug:(debug) print lem debug locations"
        "-help:Display this list of options"
        "--help:Display this list of options"
        )
        _describe -t subcommands 'ott subcommands' subcommands && ret=0
    esac

    return ret
}

compdef _ott_commands ott
